{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-900e2ded8fe2c4a1.js","src/index.ts","node_modules/effector/effector.mjs","node_modules/effector/effector/collection.ts","node_modules/effector/effector/throw.ts","node_modules/effector/effector/region.ts","node_modules/effector/effector/createNode.ts","node_modules/effector/effector/tag.ts","node_modules/effector/effector/kernel.ts","node_modules/effector/effector/naming.ts","node_modules/effector/effector/config.ts","node_modules/effector/effector/template.ts","node_modules/effector/effector/createUnit.ts","node_modules/effector/effector/combine.ts","node_modules/effector/effector/defer.ts","node_modules/effector/effector/createEffect.ts","node_modules/effector/effector/attach.ts","node_modules/effector/effector/createApi.ts","node_modules/effector/effector/createDomain.ts","node_modules/effector/effector/fromObservable.ts","node_modules/effector/effector/merge.ts","node_modules/effector/effector/sample.ts","node_modules/effector/effector/guard.ts","node_modules/effector/effector/restore.ts","node_modules/effector/effector/split.ts","node_modules/effector/effector/fork/allSettled.ts","node_modules/effector/effector/fork/util.ts","node_modules/effector/effector/fork/fork.ts","node_modules/effector/effector/fork/createScope.ts","node_modules/effector/effector/fork/hydrate.ts","node_modules/effector/effector/fork/scopeBind.ts","node_modules/effector/effector/fork/serialize.ts","node_modules/effector/effector/observable.ts","node_modules/effector/effector/validate.ts","node_modules/effector/effector/is.ts","node_modules/effector/effector/id.ts","node_modules/effector/effector/step.ts","node_modules/effector/effector/stateRef.ts","node_modules/effector/effector/caller.ts","node_modules/effector/effector/getter.ts","node_modules/effector/effector/own.ts","node_modules/effector/effector/clearNode.ts","node_modules/effector/effector/subscription.ts","node_modules/effector/effector/forward.ts","node_modules/effector/effector/watch.ts","node_modules/@parcel/transformer-js/src/esmodule-helpers.js"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";module.bundle.HMR_BUNDLE_ID = \"5c1b77e3b71e74eb\";\"use strict\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */\n\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: mixed;\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function accept(fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function dispose(fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData = undefined;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets\n/*: {|[string]: boolean|} */\n, acceptedAssets\n/*: {|[string]: boolean|} */\n, assetsToAccept\n/*: Array<[ParcelRequire, string]> */\n;\n\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\n\nfunction getPort() {\n  return HMR_PORT || location.port;\n} // eslint-disable-next-line no-redeclare\n\n\nvar parent = module.bundle.parent;\n\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe\n\n  ws.onmessage = function (event\n  /*: {data: string, ...} */\n  ) {\n    checkedAssets = {}\n    /*: {|[string]: boolean|} */\n    ;\n    acceptedAssets = {}\n    /*: {|[string]: boolean|} */\n    ;\n    assetsToAccept = [];\n    var data\n    /*: HMRMessage */\n    = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n\n      var assets = data.assets.filter(function (asset) {\n        return asset.envHash === HMR_ENV_HASH;\n      }); // Handle HMR Update\n\n      var handled = assets.every(function (asset) {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n\n      if (handled) {\n        console.clear();\n        assets.forEach(function (asset) {\n          hmrApply(module.bundle.root, asset);\n        });\n\n        for (var i = 0; i < assetsToAccept.length; i++) {\n          var id = assetsToAccept[i][1];\n\n          if (!acceptedAssets[id]) {\n            hmrAcceptRun(assetsToAccept[i][0], id);\n          }\n        }\n      } else {\n        window.location.reload();\n      }\n    }\n\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ansiDiagnostic = _step.value;\n          var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n          console.error(' [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe\n\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n\n  ws.onerror = function (e) {\n    console.error(e.message);\n  };\n\n  ws.onclose = function () {\n    console.warn('[parcel]  Connection to the HMR server was lost');\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel]  Error resolved');\n  }\n}\n\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  var errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n\n  var _iterator2 = _createForOfIteratorHelper(diagnostics),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var diagnostic = _step2.value;\n      var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;\n      errorHTML += \"\\n      <div>\\n        <div style=\\\"font-size: 18px; font-weight: bold; margin-top: 20px;\\\">\\n          \\uD83D\\uDEA8 \".concat(diagnostic.message, \"\\n        </div>\\n        <pre>\").concat(stack, \"</pre>\\n        <div>\\n          \").concat(diagnostic.hints.map(function (hint) {\n        return '<div> ' + hint + '</div>';\n      }).join(''), \"\\n        </div>\\n        \").concat(diagnostic.documentation ? \"<div>\\uD83D\\uDCDD <a style=\\\"color: violet\\\" href=\\\"\".concat(diagnostic.documentation, \"\\\" target=\\\"_blank\\\">Learn more</a></div>\") : '', \"\\n      </div>\\n    \");\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\n\nfunction getParents(bundle, id)\n/*: Array<[ParcelRequire, string]> */\n{\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction updateLink(link) {\n  var newLink = link.cloneNode();\n\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n\n  newLink.setAttribute('href', // $FlowFixMe\n  link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe\n\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\n\nvar cssTimeout = null;\n\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href\n      /*: string */\n      = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;\n\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n\n    cssTimeout = null;\n  }, 50);\n}\n\nfunction hmrApply(bundle\n/*: ParcelRequire */\n, asset\n/*:  HMRAsset */\n) {\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        var oldDeps = modules[asset.id][1];\n\n        for (var dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            var id = oldDeps[dep];\n            var parents = getParents(module.bundle.root, id);\n\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n\n      var fn = new Function('require', 'module', 'exports', asset.output);\n      modules[asset.id] = [fn, deps];\n    } else if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\n\nfunction hmrDelete(bundle, id) {\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    var deps = modules[id][1];\n    var orphans = [];\n\n    for (var dep in deps) {\n      var parents = getParents(module.bundle.root, deps[dep]);\n\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n\n\n    delete modules[id];\n    delete bundle.cache[id]; // Now delete the orphans.\n\n    orphans.forEach(function (id) {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\n\nfunction hmrAcceptCheck(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n, depsByBundle\n/*: ?{ [string]: { [string]: string } }*/\n) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  } // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n\n\n  var parents = getParents(module.bundle.root, id);\n  var accepted = false;\n\n  while (parents.length > 0) {\n    var v = parents.shift();\n    var a = hmrAcceptCheckOne(v[0], v[1], null);\n\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      var p = getParents(module.bundle.root, v[1]);\n\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n\n      parents.push.apply(parents, _toConsumableArray(p));\n    }\n  }\n\n  return accepted;\n}\n\nfunction hmrAcceptCheckOne(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n, depsByBundle\n/*: ?{ [string]: { [string]: string } }*/\n) {\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n\n  if (checkedAssets[id]) {\n    return true;\n  }\n\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToAccept.push([bundle, id]);\n\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n}\n\nfunction hmrAcceptRun(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n  cached = bundle.cache[id];\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      var assetsToAlsoAccept = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n\n      if (assetsToAlsoAccept && assetsToAccept.length) {\n        // $FlowFixMe[method-unbinding]\n        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);\n      }\n    });\n  }\n\n  acceptedAssets[id] = true;\n}","import { createEffect } from \"effector\";\r\nimport { fxLoadSounds, test } from \"./features/Player/model\";\r\n\r\nconsole.log('foo');\r\n// const root = document.getElementById('root');\r\n\r\nconst fx = createEffect(console.log);\r\nfx()",null,"export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: any, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: any,\n  subject: string,\n  suggestion: string,\n) =>\n  !condition &&\n  console.error(`${subject} is deprecated, use ${suggestion} instead`)\n","import {getParent, getMeta} from './getter'\nimport {createNode} from './createNode'\nimport type {Template} from '../forest/index.h'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), name, loc, method},\n  })\n  return withRegion(sidNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\nexport type Stack = {\n  value: any\n  a: any\n  b: any\n  c?: any\n  parent: Stack | null\n  node: Node\n  page: Leaf | null\n  scope?: Scope | null | void\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, scope: forkPage, isWatch}\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem(\n          'child',\n          page,\n          nextNode,\n          stack,\n          finalValue,\n          getForkPage(stack),\n        )\n      })\n      const forkPage = getForkPage(stack)\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = scope.sidValuesMap[sid]\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\nimport {forIn} from './collection'\n\nconst getCompostite = (unit: any): CompositeName => unit.compositeName\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, (unit: any) => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit) ? getCompostite(unit).fullName : unit.toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompostite(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompostite(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any,\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  if (rawConfig.and) {\n    args = rawConfig.and\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: any = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn: any = template.handlers[method]\n    if (fn) return fn(template, ...args)\n  }\n}\n","import {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport type {Store, Event} from './unit.h'\n\nimport {calc, compute, filter, mov, read} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n} from './kernel'\n\nimport type {Subscriber, Config} from './index.h'\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: any, unit: any, configA: any, configB?: any) => {\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const config = flattenConfig({\n    or: configB,\n    and: typeof configA === 'string' ? {name: configA} : configA,\n  })\n  const {parent = null, sid = null, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName}  *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  const template = readTemplate()\n  return Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(EVENT, event, nameOrConfig, maybeConfig),\n      regional: true,\n    }),\n    create(params: any, _: any) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: any) => deriveEvent(event, MAP, fn, [compute({fn: callStack})]),\n    filter: (fn: any) =>\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [filter({fn: callStack})]),\n    filterMap: (fn: any) =>\n      deriveEvent(event, 'filterMap', fn, [\n        compute({fn: callStack}),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: any) {\n      const contramapped: Event<any> = createEvent('*  ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(\n        contramapped,\n        event,\n        [compute({fn: callStack})],\n        'prepend',\n        fn,\n      )\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: any) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: any[]) {\n      forEach(units, unit => store.on(unit, () => store.defaultState))\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      deprecate(\n        !getMeta(store, 'derived'),\n        '.on in derived store',\n        'createStore',\n      )\n      forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n        store.off(trigger)\n        getSubscribers(store).set(\n          trigger,\n          createSubscription(\n            updateStore(trigger, store, 'on', callARegStack, fn),\n          ),\n        )\n      })\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = fn.fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName}  *`,\n        derived: true,\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && filter({fn: callStackAReg}),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    if (getMeta(store, 'serialize') !== 'ignore')\n      setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  assert(\n    getMeta(store, 'derived') || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, compute({fn: caller})]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, compute, calc, read} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport {callStack} from './caller'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    read(rawShape),\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && compute({fn: callStack}),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch, Stack} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport type {Unit} from './index.h'\nimport {add} from './collection'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig?: any,\n) {\n  const instance: any = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        ({params, req, handler, args = [params]}, _, stack) => {\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd = getParent(stack)\n          ? {params, req: {rs(data: any) {}, rj(data: any) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({target: instance, params: payload, scope: forkPage})\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): any\n      rj(_: any): any\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  (data: any) =>\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      page: stack.page,\n      scope: getForkPage(stack),\n    })\n\nexport const sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {combine} from './combine'\nimport {createEffect, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {getGraph, getStoreState, setMeta} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const rj = onSettled(params, req, false, anyway, stack)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams: any\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {rs: onSettled(params, req, true, anyway, stack), rj},\n            },\n            page: stack.page,\n            defer: true,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const node = createNode({family: {type: DOMAIN}, regional: true})\n\n  const result: any = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  }\n\n  node.meta = initUnit(DOMAIN, result, nameOrConfig, maybeConfig)\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory: any, tag) => {\n      const lowerCaseTag = tag.toLowerCase()\n\n      const trigger = createNamedEvent(`on${tag}`)\n      result.hooks[lowerCaseTag] = trigger\n\n      const acc = new Set<any>()\n      result.history[`${lowerCaseTag}s`] = acc\n\n      trigger.create = res => {\n        launch(trigger, res)\n        return res\n      }\n      add(\n        getGraph(trigger).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      trigger.watch(data => {\n        own(result, [data])\n        acc.add(data)\n        if (!data.ownerSet) data.ownerSet = acc\n        if (!getParent(data)) data.parent = result\n      })\n      own(result, [trigger])\n\n      result[`onCreate${tag}`] = (hook: (data: any) => any) => {\n        forEach(acc, hook)\n        return trigger.watch(hook)\n      }\n      result[`create${tag}`] = result[lowerCaseTag] = (\n        nameOrConfig: any,\n        config?: Config,\n      ) => trigger(factory(nameOrConfig, {parent: result, or: config}))\n    },\n  )\n\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  return result\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  createLinkNode(events, result, [], 'merge')\n  return result\n}\n","import {combine} from './combine'\nimport {mov, compute, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject, isVoid} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\nexport const groupInputs = (source: any, clock: any, method: string) => {\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  if (isVoid(source)) {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  return [source, clock] as const\n}\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, 'sample')\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  ;[source, clock] = groupInputs(source, clock, 'sample')\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  if (!metadata && !name) name = source.shortName\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent(name, metadata)\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(\n        clock,\n        target,\n        [\n          applyTemplate('sampleSourceLoader'),\n          read(sourceRef, !fn, batched),\n          fn && compute({fn: callARegStack}),\n          applyTemplate('sampleSourceUpward', isUpward),\n        ],\n        SAMPLE,\n        fn,\n        // scope: {fn, targetTemplate}\n      ),\n    ])\n    applyTemplate('sampleStoreSource', sourceRef)\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceRef = createStateRef()\n    const clockState = createStateRef()\n    applyTemplate('sampleNonStoreSource', hasSource, sourceRef, clockState)\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: SAMPLE},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(\n        clock,\n        target,\n        [\n          applyTemplate('sampleSourceLoader'),\n          mov({from: STACK, target: clockState}),\n          read(hasSource, true),\n          calc(hasSource => hasSource, true),\n          read(sourceRef, true, batched),\n          read(clockState),\n          fn && compute({fn: callStackAReg}),\n          applyTemplate('sampleSourceUpward', isUpward),\n        ],\n        SAMPLE,\n        fn,\n        // scope: {fn, targetTemplate}\n      ),\n    ])\n  }\n  return target\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {groupInputs, validateSampleConfig, sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {calc, filter} from './step'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\n\nexport function guard(...args: any[]) {\n  const METHOD = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, METHOD)\n  let {\n    filter: filterFn,\n    greedy,\n    clock,\n    name = metadata && metadata.name ? metadata.name : METHOD,\n  } = config\n  const target = config.target || createEvent(name, metadata)\n  const filterIsUnit = is.unit(filterFn)\n  ;[source, clock] = groupInputs(source, clock, METHOD)\n  if (clock) {\n    assertNodeSet(clock, METHOD, 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, METHOD, 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filterFn,\n      clock: source,\n      target: createNode({\n        node: [calc(({guard}) => guard, true), calc(({data}) => data)],\n        child: target,\n        meta: {op: METHOD},\n        family: {\n          owners: [source, filterFn, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    assert(isFunction(filterFn), '`filter` should be function or unit')\n    createLinkNode(\n      source,\n      target,\n      clock\n        ? [\n            filter({fn: ({source, clock}, {fn}) => fn(source, clock)}),\n            calc(({source}) => source),\n          ]\n        : [filter({fn: callStack})],\n      METHOD,\n      filterFn,\n    )\n  }\n  return target\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) return obj\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import type {Event} from './unit.h'\nimport type {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, filter, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(match, (_, key) => (targets[key] = createEvent(metadata)))\n    targets.__ = createEvent(metadata)\n  }\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {op: 'split'},\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: Scope; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-expect-error\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits = [start]\n  const launchParams = [] as Array<{params: any; req: any} | null>\n  add(\n    launchParams,\n    is.effect(start)\n      ? {\n          params: ctx,\n          req: {\n            rs(value: any) {\n              //@ts-ignore\n              defer.value = {status: 'done', value}\n            },\n            rj(value: any) {\n              //@ts-ignore\n              defer.value = {status: 'fail', value}\n            },\n          },\n        }\n      : ctx,\n  )\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\nexport function normalizeValues(\n  values: Map<Store<any>, any> | Array<[any, any]> | Record<string, any>,\n  assertEach?: (key: any, value: any) => void,\n) {\n  if (Array.isArray(values)) values = new Map(values)\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    forEach(values, (value, key) => {\n      assert(is.unit(key), 'Map key should be a unit')\n      if (assertEach) assertEach(key, value)\n      assert(key.sid, 'unit should have a sid')\n      assert(!(key.sid! in result), 'duplicate sid found')\n      result[key.sid!] = value\n    })\n    return result\n  }\n  return values\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\n\nexport function fork(\n  domainOrConfig?: Domain | {values?: any; handlers?: any},\n  optiionalConfig?: {values?: any; handlers?: any},\n) {\n  let config: {values?: any; handlers?: any} | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optiionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    if (config.values) {\n      const valuesSidMap = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.sidValuesMap, valuesSidMap)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (_, scope) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack && getParent(storeStack)) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            getMeta(getParent(storeStack).node, 'op') !== 'combine'\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.sidValuesMap[sid] = value\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    getState(store: any) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n  }\n  return resultScope\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: any}) {\n  assert(isObject(values), 'values property should be an object')\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      add(storeNodes, node)\n      add(storeValues, normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.sidValuesMap, normalizedValues)\n  }\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(unit: any, {scope}: {scope?: Scope} = {}) {\n  assert(\n    scope || forkPage,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = scope.reg[id].current\n    } else {\n      result[sid] = value\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {Domain, Effect, Event, Scope, Store} from './unit.h'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: any) => value is Store<unknown>\nexport const event = is(EVENT) as (value: any) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: any,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: any) => value is Domain\nexport const scope = is(SCOPE) as (value: any) => value is Scope\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const isVoid = (value: any) => value === undefined\n\nexport const assertObject = (value: any) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: any,\n  method: string,\n  valueName: string,\n  reason: string,\n) =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: any,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag, Stack} from './kernel'\n\nconst cmd = (\n  type: 'compute' | 'mov',\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: any = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = ({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n}: {\n  fn?: (data: any, scope: {[key: string]: any}, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n}): Compute => cmd('compute', {fn, safe, filter}, priority, batch)\n\nexport const filter = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, filter: true})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import type {Stack} from './kernel'\n\nexport const callStackAReg = (stack: any, {fn}: any, {a}: Stack) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: Stack) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: Stack) => fn(stack)\n","import type {Node, StateRef} from './index.h'\nimport type {Scope} from './unit.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: any, field: string) => getGraph(unit).meta[field]\nexport const setMeta = (unit: any, field: string, value: any) =>\n  (getGraph(unit).meta[field] = value)\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: 'forward', config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n"],"names":["createEffect","fxLoadSounds","test","console","log","fx","forIn","obj","cb","key","forEach","list","fn","assert","condition","message","Error","withRegion","unit","regionStack","parent","value","template","getMeta","readTemplate","sidRoot","getParent","createNode","node","from","source","to","target","child","scope","meta","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","item","add","result","id","nextNodeID","next","link","getOwners","owner","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","getForkPage","Array","isArray","i","length","pushFirstHeapItem","getGraph","isRoot","stop","skip","reg","lastStartedState","isWatch","kernelLoop","deleteMin","idx","stack","hasPageReg","hasScopeReg","local","fail","stepn","step","order","priority","barrierID","fullID","barriers","has","pushHeap","delete","data","STACK","store","pageForRef","getPageForRef","initRefInScope","softRead","undefined","readRef","getPageRef","current","computationResult","safe","tryRun","filter","finalValue","nextNode","fxCount","storeChange","additionalLinks","unitObjectName","objOrArr","method","name","comma","is","getCompostite","fullName","toString","setStoreName","rawName","shortName","Object","assign","createName","path","composite","concat","processArgsToConfig","args","singleArgument","rawConfig","assertObject","and","or","applyTemplate","handlers","createEvent","nameOrConfig","maybeConfig","event","deprecate","oldPage","setCurrentPage","create","callCreate","graphite","initUnit","watch","watchUnit","map","deriveEvent","MAP","compute","callStack","filterMap","calc","isVoid","prepend","contramapped","createLinkNode","applyParentHook","createStore","defaultState","props","plainState","createStateRef","updates","createNamedEvent","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","reset","units","on","nodeSet","assertNodeSet","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","currentSubscription","get","firstState","config","lastResult","isObject","storeState","innerStore","derived","linkNode","callStackAReg","addRefOp","getStoreState","noInit","eventOrFn","subscription","isFunction","updateFilter","defaultConfig","upd","_","b","read","a","mov","sid","setMeta","combine","handler","stores","structStoreShape","shapeReady","noArraySpread","rawHandler","slice","storeCombination","createStoreObject","createDefer","req","Promise","rs","rj","catch","err","instance","kind","use","runner","getCurrent","anyway","finally","done","named","status","error","doneData","failData","handlerId","getType","scope_","handler_","onResolve","onSettled","onReject","ok","runFn","then","op","savedFork","setForkPage","inFlight","x","pending","amount","attach","injected","effect","mapParams","attached","runnerSteps","runnerFnStep","computedParams","sourceData","isEffectHandler","splice","createApi","setters","metadata","createDomain","history","hooks","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","acc","Set","res","ownerSet","hook","fromObservable","observable","observableItem","observableSymbol","subscribe","disposer","complete","merge","events","validateSampleConfig","atLeastOneFieldExists","sampleConfigFields","field","fieldErrorMessage","sample","clock","batched","greedy","groupInputs","isUpward","sourceRef","hasSource","clockState","guard","METHOD","filterFn","filterIsUnit","restore","domain","split","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","__","splitterSeq","values","caseNames","keys","scopeTargets","String","launchCase","includes","lastValues","needBarrier","storeOrFn","updater","storeRef","caseName","allSettled","start","ctx","reject","parentFork","defers","launchUnits","launchParams","traverseStores","root","visit","normalizeValues","assertEach","fork","domainOrConfig","optiionalConfig","forkInFlightCounter","fxID","batch","resolve","storeStack","storeNode","sidIdMap","sidValuesMap","resultScope","cloneOf","createScope","valuesSidMap","hydrate","traverseTarget","needToAssign","normalizedValues","valuesSidList","getOwnPropertyNames","storeNodes","storeValues","scopeBind","savedForkPage","serialize","ignoredStores","ignore","onlyChanges","Symbol","removeItem","pos","indexOf","push","subject","suggestion","assertNodeSetItem","valueName","reason","idCount","nextUnitID","nextStepID","cmd","nextBarrierID","run","isEffect","toStack","samplerPriority","ref","before","graph","val","ownerUnit","_link","readSidRoot","withFactory","loc","flat","heap","ret","v","getPriority","r","l","queue","ix","first","last","size","bucket","t","newForkPage","newPage","isGetState","isKernelCall","refsMap","isFresh","compositeName","flattenConfig","part","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","effects","domains","unsubscribe","scopeFn","forward","opts","hookType","configA","configB","isDomain","unitId","thru","observer","nativeTemplate","mapped","caller","reader","needSpread","clone","stateNew","rawShape","storeStateRef","c","childRef","defaultShape","sidechain"],"version":3,"file":"index.b71e74eb.js.map","sourceRoot":"/__parcel_source_root/"}